# =====================================================
# Класс который станет родителем для другова класса
class Class1():
    def func_1(self):
        print('Метод func_1 класса Class1')
    def func_2(self):
        print('Метод func_2 класса Class1')

# Дочерний класс, наследуется от базового
class Class2(Class1):
    def func_3(self):
        print('Метод func_3 класса Class2')

с = Class2()
с.func_1()
с.func_2()
с.func_3()



# =====================================================
# Специальные методы
class Class3():
    print('/*===== Специальные методы классов __call__ =====*/')

    # __init__
    def __init__(self, msg):
        self.msg = msg

    # __call__ - Метод вызывается когда экз-рт класса вызывается как функция
    def __call__(self):
        print(self.msg)

# Создаем экз-ры и передаем им сообщения
c31 = Class3('1) Сообщение из метода __call__')
c32 = Class3('2) Сообщение из метода __call__')
# Выводим маг.методы экземпляров класса
c31.__call__()
c32.__call__()



# =====================================================
class Class4:
    print('/*===== Специальные методы классов __getattr__ =====*/')

    def __init__(self, i):
        self.i = i

    # Магический метод __getattr__ вызывается если атрибута не существует, 2 - аргумент это название атрибута
    def __getattr__(self, item):
        print(f"Вызван метод __getattr__ потому что атрибут '{item}' у данного класса не существует")


c4 = Class4(20)
print(c4.i)
c4.attribut # будет вызван маг.метод потому что данного атрибута у класса не существут
c4.attribut = 'Теперь существует'
print(c4.attribut)




# =====================================================
class Class5:
    print('/*===== Специальные методы классов __getattribute__ =====*/')

    # Метод инициализации __init_()   должен возвращать тип Nano тоесть ничего
    def __init__(self, i):
        self.i = i

    # __getattribute__ Вызывается при обращении к любому атрибуту класса
    # По сути своей когда мы обращаемся к любому атрибуту любого класса, срабатывает
    # именно этот метод, если мы будем возвращать return self.item То он вызовет себя
    # самого, и мы получим ошибку типа: RecursionError: maximum recursion depth exceeded
    # Чтобы этого избежать надо исп-ть это: object.__getattribute__(self, item)
    def __getattribute__(self, item):
        print('Вызван метод __getattribute__()')
        return object.__getattribute__(self, item)

c5 = Class5(30)
print(c5.i)



# =====================================================
class Class6:
    print('/*===== Специальные методы классов __setattr__ =====*/')

    # Вызывается при внесения значения в атрибут экземпляра класса,
    # Если мы присваеваем значение атрибуту этогоже экземпляра класса то
    # надо использовать словарь __dict__ иниче метод __setattr__() будет вызван
    # повторно и будет зацкливание.
    def __setattr__(self, key, value):
        print('Вызван метод __setattr__()')
        self.__dict__[key] = value # Только так можно присвоить значение атрибуту класса
        print(f'Атрибуту {key} присвоено значение {value}')

c6 = Class6
c6.i = 20
print(c6.i)









# l = [1,2, 'apple']
# l.insert(1, 'apple')
# print(l)
#
# # extend
#
# l = list('acbd')
# l.sort()
# print(l)
# print(''.join(l))
