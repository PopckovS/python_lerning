# Класс для описания Машины
class Car():
    """Класс по созданию автомобиля"""


    def __init__(self, make, model, year):
        """Инициализируем марка, модель, год выпуска автомобиля"""
        self.make  = make
        self.model = model
        self.year  = year

    def description_name(self):
        """Возвращаем описание автомобиля"""
        desc = str(self.year) + ' ' + self.make + ' ' + self.model
        return desc.title()

car = Car('General Motors', 'BMW', 1984)
print(car.description_name())



class Class1():

    '''Класс для эксперимента с динамическими и статическими методами'''

    # Статический метод класса
    # Он может быть вызван как без экземпляра класса, так и с ним.
    # @staticmethod - это называется декоратором, он указывается перед методом
    # по сути явл-ся указанием на то что метод, явл-ся статическим.
    # не требуется указания ключевого слова self ибо он статичен, и не требует обьекта
    @staticmethod
    def test_1(x, y):
        return f'Статический метод: {x} + {y} = {x+y}'

    # Обычный метод класса
    # Если перед строкоой поставить символ f то все что будет
    # записано в строку, будет исполнено как програмный код
    def test_2(self, x, y):
        return f'Обычный метод: {x} + {y} = {x+y}'

    # Обычный метод класса, служит оберткой для статического метода класса
    def test_3(self, x, y):
        return 'Обычный метод оборачивает ' + str(self.test_1(x, y))
        # return 'Обычный метод оборачивает ' + str(Class1.test_1(x, y))


c_1 = Class1()

# Статический метод вызванный, как самостоятельно так и от экземпляра класса
print(Class1.test_1(5, 5))
print(c_1.test_1(6, 6))

# Вызываю динамический метод
print(c_1.test_2(5, 5))

# Вызываю статический метод через динамический метод
print(c_1.test_3(5, 5))
