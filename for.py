'''Цикл for - То что в других языках называется foreach в Python называется просто for.
Цикл for используется для итерации по последовательности (list, tuple, dict, set или str).
В том числе и строки(str) тоэе по сути своей просто массив символов.'''
start_block = '================='


'''Обычный цикл for с обычным выводом всех его эллементов, Цикл for не требует создания дополнительных 
переменных для итерации. Тоесть ведет себя как упращеенный вариант цикла foreach в языке php '''
print(start_block)
# Простой вывод всех эллементов списка
fruits = ["яблоко", "мандарин", "вишня"]
for x in fruits:
    print(x)
# Answer:
#   яблоко
#   мандарин
#   вишня


'''Благодаря оператору break мы можем остановить цикл прежде чем он закончится по всем элементам,
break - прекращает вывод всего массива после себя'''
print(start_block)
fruits = ["яблоко", "банан", "вишня"]
for x in fruits: # Начало вывода эллемента за эллементом
    print(x)
    if x == "банан": # В случае если слово "банан" то цикл будет прерван
        break
# Answer:
#   яблоко
#   банан


'''С помощью оператора continue мы можем остановить текущую итерацию цикла и перейти к следующей
continue - пропускает вывод одного эллемента, но не останавливает проход по всему списку'''
print(start_block)
# Пропустим вывод “банан”
fruits = ["яблоко", "банан", "вишня"]
for x in fruits:
    if x == "банан":
        continue
    print(x)
# Answer:
#   яблоко
#   вишня


'''Функция range() - применяется что бы выполнить действия заданное количество раз. 
Она возвращает последовательность чисел, начиная с 0 (по умолчанию) увеличивает число на 1 (по умолчанию) 
и заканчивая до указанного числа.'''
print(start_block)
# Генерация шести чисел: 0,1,2,3,4,5 начиная с нуля и до указанного
for x in range(6):
    print(x)

'''Функция range() по умолчанию начинается с 0, однако можно изменить начальное значение, 
добавив параметр: range (2, 6), что означает значения от 2 до 6 (но не включая 6)'''
# Генерация чисел с 2 до 6 не включая 6
for x in range(2, 6):
    print(x)


'''Функция range () по умолчанию увеличивает последовательность на 1, однако можно указать значение
приращения, добавив третий параметр: range (2, 30, 3)'''
# Генерируем с 2 до 30 шагом 3
for x in range(2, 30, 3):
    print(x, end=' ')
# Answer: 0 1 2 3 4 5
# Answer: 2 3 4 5
# Answer: 2 5 8 11 14 17 20 23 26 29


'''Ключевое слово else в цикле for включает блок кода, который должен быть выполнен после завершения цикла.
else - завершающий кусочек кода выполняется в конце цикла, это особенность for в языке Python.'''
print('\n'+start_block)
# Обычный вывод цикла с завершающим блоком
for x in range(6):
    print(x)
else:
    print("Цикл завершен!")
# Answer: 0 1 2 3 4 5 Цикл завершен!



'''В случае использования ключевого слова break завершающийй блок else игнорируется полностью.'''
print(start_block)
for x in range(6):
    print(x)
    if x == 3:
        break
else:
    print("Цикл завершен!")
# Answer: 0 1 2 3


'''В случае использования ключевого слова continue завершающийй блок else исполняется.'''
print(start_block)
for x in range(6):
    if x > 3:
        continue
    print(x)
else:
    print("Цикл завершен!")
# Answer: 0 1 2 3 Цикл завершен!


'''Вложенный цикл — это цикл в цикле. Он будет запускаться при каждой итерации основного цикла.
Выведем все фрукты с каждым прилагательным. Тоесть количество выполнений буде равно перемножению 2 списков.'''
print(start_block)
adj = ["желтый", "большой", "вкусный"]
fruits = ["апельсин", "банан", "ананас"]
for x in adj: # Основной цикл, выполняется по 3 раза, для каждого эллемента списка
    for y in fruits: # Вложенный цикл, выполняется каждый раз, для каждого запуска основного цикла
        print(x, y)  # Вывод, выполняется 9 раз, как перемножение длин двух списков
# Answer:
#     желтый апельсин
#     желтый банан
#     желтый ананас
#     большой апельсин
#     большой банан
#     большой ананас
#     вкусный апельсин
#     вкусный банан
#     вкусный ананас


'''Рекурсия - функция может вызывать сама себя. Как это работает, даем на вход число 6 оно > 0
происходит вызов этойже функции и передаем ей число (6 - 1 = 5). Тоесть число 5, далее все повторяется 4, 3, 2, 1.
Но не 0, вывод в терминал начинается с самого глубокого вызова, где: 
1+((1-1) return 0)  =  1+0  =  1
2+((2-1) return 1)  =  2+1  =  3
3+((3-1) return 3)  =  3+3  =  6
4+((4-1) return 6)  =  4+6  =  10
5+((5-1) return 10) =  5+10 =  15
6+((6-1) return 15) =  6+15 =  21
'''
print(start_block)

def tri_recursion(k):
    if (k > 0):
        result_resursion = tri_recursion(k - 1)
        result = k + result_resursion
        print('Переменная k = {0} вызов функции: {1} + {2} = {3}'.format(k, k, result_resursion, result))
    else:
        result = 0
    return result

print("\n\nРезультат примера рекурсии")
tri_recursion(6)
# Answer: 1 3 6 10 15 21


''''''
print(start_block)
print()
# Answer: